/*
 * Client Portal Web API
 *
 * Client Portal Web API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `iserver_account_account_id_order_order_id_delete`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAccountIdOrderOrderIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `iserver_account_account_id_order_order_id_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAccountIdOrderOrderIdPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `iserver_account_account_id_order_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAccountIdOrderPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `iserver_account_account_id_order_whatif_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAccountIdOrderWhatifPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `iserver_account_account_id_orders_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAccountIdOrdersPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `iserver_account_orders_fa_group_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountOrdersFaGroupPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `iserver_account_orders_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountOrdersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `iserver_reply_replyid_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverReplyReplyidPostError {
    Status400(crate::models::InlineResponse400),
    UnknownValue(serde_json::Value),
}


/// Cancels an open order. Must call /iserver/accounts endpoint prior to cancelling an order. Use /iservers/account/orders endpoint to review open-order(s) and get latest order status.
pub async fn iserver_account_account_id_order_order_id_delete(configuration: &configuration::Configuration, account_id: &str, order_id: &str) -> Result<crate::models::InlineResponse20016, Error<IserverAccountAccountIdOrderOrderIdDeleteError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/iserver/account/{accountId}/order/{orderId}", configuration.base_path, accountId=crate::apis::urlencode(account_id), orderId=crate::apis::urlencode(order_id));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<IserverAccountAccountIdOrderOrderIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Modifies an open order. Must call /iserver/accounts endpoint prior to modifying an order. Use /iservers/account/orders endpoint to review open-order(s).
pub async fn iserver_account_account_id_order_order_id_post(configuration: &configuration::Configuration, account_id: &str, order_id: &str, body: crate::models::ModifyOrder) -> Result<Vec<crate::models::InlineResponse20015>, Error<IserverAccountAccountIdOrderOrderIdPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/iserver/account/{accountId}/order/{orderId}", configuration.base_path, accountId=crate::apis::urlencode(account_id), orderId=crate::apis::urlencode(order_id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<IserverAccountAccountIdOrderOrderIdPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Please note here, sometimes this endpoint alone can't make sure you submit the order successfully, you could receive some questions in the response, you have to to answer them in order to submit the order successfully. You can use \"/iserver/reply/{replyid}\" endpoint to answer questions 
pub async fn iserver_account_account_id_order_post(configuration: &configuration::Configuration, account_id: &str, body: crate::models::OrderRequest) -> Result<Vec<crate::models::InlineResponse20012>, Error<IserverAccountAccountIdOrderPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/iserver/account/{accountId}/order", configuration.base_path, accountId=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<IserverAccountAccountIdOrderPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. 
pub async fn iserver_account_account_id_order_whatif_post(configuration: &configuration::Configuration, account_id: &str, body: crate::models::OrderRequest) -> Result<crate::models::InlineResponse20014, Error<IserverAccountAccountIdOrderWhatifPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/iserver/account/{accountId}/order/whatif", configuration.base_path, accountId=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<IserverAccountAccountIdOrderWhatifPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// You can pass a list of orders here 
pub async fn iserver_account_account_id_orders_post(configuration: &configuration::Configuration, account_id: &str, body: crate::models::InlineObject4) -> Result<Vec<crate::models::InlineResponse20012>, Error<IserverAccountAccountIdOrdersPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/iserver/account/{accountId}/orders", configuration.base_path, accountId=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<IserverAccountAccountIdOrdersPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Financial Advisors can use this endpoint to place an order for a specified group. To place an order for a specified account use the endpoint /iserver/account/{accountId}/order. More information about groups can be found in the [TWS Users' Guide:](https://guides.interactivebrokers.com/twsguide/twsguide.htm#usersguidebook/financialadvisors/create_an_account_group_for_share_allocation.htm). 
pub async fn iserver_account_orders_fa_group_post(configuration: &configuration::Configuration, fa_group: &str, body: crate::models::OrderRequest) -> Result<Vec<crate::models::InlineResponse20012>, Error<IserverAccountOrdersFaGroupPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/iserver/account/orders/{faGroup}", configuration.base_path, faGroup=crate::apis::urlencode(fa_group));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<IserverAccountOrdersFaGroupPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The endpoint is meant to be used in polling mode, e.g. requesting every x seconds. The response will contain two objects, one is notification, the other is orders.  Orders is the list of live orders (cancelled, filled, submitted).  Notifications contains information about execute orders as they happen, see status field. To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
pub async fn iserver_account_orders_get(configuration: &configuration::Configuration, body: Option<crate::models::InlineObject3>) -> Result<crate::models::InlineResponse20011, Error<IserverAccountOrdersGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/iserver/account/orders", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<IserverAccountOrdersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Reply to questions when placing orders and submit orders
pub async fn iserver_reply_replyid_post(configuration: &configuration::Configuration, replyid: &str, body: crate::models::InlineObject5) -> Result<Vec<crate::models::InlineResponse20013>, Error<IserverReplyReplyidPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/iserver/reply/{replyid}", configuration.base_path, replyid=crate::apis::urlencode(replyid));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<IserverReplyReplyidPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

